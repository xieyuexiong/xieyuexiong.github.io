{"meta":{"title":"Zealot","subtitle":"嗨 我是谢月熊","description":"αȫջ","author":"Zealot","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Linux常用命令-4","slug":"Linux常用命令-4","date":"2019-09-19T15:39:01.000Z","updated":"2019-09-23T13:40:00.787Z","comments":true,"path":"2019/09/19/Linux常用命令-4/","link":"","permalink":"http://yoursite.com/2019/09/19/Linux常用命令-4/","excerpt":"","text":"帮助命令：1.命令名称：man 语法：man [命令或配置文件] 功能描述：获得帮助信息 man ls —–查看ls命令的帮助信息 5 –配置文件 1 –帮助的命令 2.命令名称：hlep 语法：help 命令 功能描述：获得Shell内置命令的帮助信息 help umask –查看umask命令的帮助信息","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux常用命令-3","slug":"Linux常用命令-3","date":"2019-09-16T13:42:48.000Z","updated":"2019-09-17T15:19:10.841Z","comments":true,"path":"2019/09/16/Linux常用命令-3/","link":"","permalink":"http://yoursite.com/2019/09/16/Linux常用命令-3/","excerpt":"","text":"文件搜索命令： 1.命令名称： find 执行权限：所有用户 语法： find [搜索范围] [匹配条件] 功能描述： 文件搜索 例： $find /etc -name init (init)模糊搜索 (init)以init开头 在目录/etc中查找文件init 匹配任意 ？匹配单个 -iname 不区分大小写 $find / -size +201800 在根目录下查找大于100MB的文件 +n 大于 -n 小于 n 等于0 $find /home -user shenchao 在home目录下查找所有者为shenchao的文件 -group 所属组的文件 $find /etc -cmin -5 在/etc下查找5分钟内被修改过属性的文件和目录 -amin 访问时间 -cmin 文件属性 -mmin 文件内容 $find / -size +201800 -a -type -f -exec ls -l {} \\; 在根目录下查找大于100MB的文件 -a and -o or -type fdl f 文件 d 目录 l 软链接文件 2.命令名称：locate 执行权限：所有用户 语法：locate 文件名 -i 不区分大小写 功能描述：在文件资料库里查找文件 updatedb 更新文件资料库 3.命令名称：which 执行权限：所有用户 语法：which 命令 功能描述：搜索命令所在目录及别名信息 which ls 4.命令名称：whereis 执行权限：所有用户 语法：whereis 命令名称 功能描述：搜索命令所在目录及帮助文档路径 whereis ls 5.命令名称：grep 执行权限：所有用户 语法：grep -iv [指定字串] [文件] 功能描述：在文件中搜寻字串匹配的行并输出 -i 不区分大小写 -v 排除指定字串范例：# grep mysql /root/install.log # grep -v ^# /etc/inittab 不显示以#开头的行","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux常用命令-2","slug":"Linux常用命令-1","date":"2019-09-14T14:20:22.000Z","updated":"2019-09-15T14:16:33.263Z","comments":true,"path":"2019/09/14/Linux常用命令-1/","link":"","permalink":"http://yoursite.com/2019/09/14/Linux常用命令-1/","excerpt":"","text":"权限管理命令： 1.命令名称：chmod 执行权限：所有用户 语法：chmod [{ugoa} {+-=} {rwx}] [文件或目录] [mode=421] [文件或目录] -R 递归修改 功能：改变文件或目录权限 2.命令名称：chown 执行权限：所有用户 语法：chown [用户] [文件或目录] 功能：改变文件或目录的所有者 3.命令名称：chgrp 执行权限：所有用户 语法：chgrp [用户组] [文件或目录] 功能：改变文件或目录的所属组 4.命令名称：umask 执行权限：所有用户 语法：umash [-S] -S 以rwx形式显示新建文件缺省权限 功能：显示、设置文件的缺省权限 注：umask [077] 这种还可以更改创建目录时的权限","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux常用命令-1","slug":"Linux常用命令","date":"2019-09-12T16:28:31.000Z","updated":"2019-09-14T14:20:48.649Z","comments":true,"path":"2019/09/13/Linux常用命令/","link":"","permalink":"http://yoursite.com/2019/09/13/Linux常用命令/","excerpt":"","text":"文件处理命令： 1.命令格式与目录处理命令ls命令格式：命令 [-选项] [参数] 例如： ls -la /etcls 选项[-ald] [文件或目录] -a 显示所有文件，包括隐藏文件 -l 详细信息显示 -d 查看目录属性 -i 查询id号 -rw-r–r– -文件类型（-二进制文件 d 目录 l 软链接文件） rw- r– r– u所有者 g所属组 o其他人 r读 w写 x执行 2.目录处理命令：创建新目录： mkdir -p [目录名] -p 递归创建切换目录： cd [目录] cd .. 回到上一级目录显示当前目录： pwd删除空目录： rmdir [目录名]复制文件或目录： cp -rp [原文件或目录] [目标目录] （复制文件不需要加选项） -r 复制目录 -p 保留文件属性剪切文件、改名： mv [原文件或目录] [目标目录]删除文件： rm -rf [文件或目录] -r 删除目录 -f 强制执行 3.文件处理命令：创建空文件： touch [文件名] 注：如果要创建带空格的文件要用双引号引起来！显示文件内容： cat -n [文件名] -n 显示行号显示文件内容（反向显示）： tac [文件名]分页显示文件内容： more [文件名] (空格)或f 翻页 （enter） 换行 q 退出分页显示文件内容（可向上翻页）： less [文件名]up键向上查询 /（想要搜索的关键字） 会高亮显示 按n向下查询显示文件前面几行： head -n [文件名] -n指定行数显示文件后面几行： tail [文件名] -n 指定行数 -f 动态显示文件末尾内容 4.链接命令：生成链接文件： ln -s [原文件] [目标文件] -s 创建软连接 软链接文件特征：类似于Windows的快捷方式 1、lrwxrwxrwx l软链接 2、文件大小-只是符号连接 3、箭头指向源文件 硬链接特征： 1、拷贝cp -p + 同步更新 2、通过i结点识别 3、不能跨分区 4、不能针对目录使用","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"CSS之定位","slug":"CSS之定位","date":"2019-06-18T10:46:51.000Z","updated":"2019-06-18T10:54:57.368Z","comments":true,"path":"2019/06/18/CSS之定位/","link":"","permalink":"http://yoursite.com/2019/06/18/CSS之定位/","excerpt":"","text":"CSS 为定位和浮动提供了一些属性，利用这些属性，可以建立列式布局，将布局的一部分与另一部分重叠，还可以完成多年来通常需要使用多个表格才能完成的任务。定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。显然，这个功能非常强大，也很让人吃惊。要知道，用户代理对 CSS2 中定位的支持远胜于对其它方面的支持，对此不应感到奇怪。另一方面，CSS1 中首次提出了浮动，它以 Netscape 在 Web 发展初期增加的一个功能为基础。浮动不完全是定位，不过，它当然也不是正常流布局。CSS 为定位和浮动提供了一些属性，利用这些属性，可以建立列式布局，将布局的一部分与另一部分重叠，还可以完成多年来通常需要使用多个表格才能完成的任务。 一切皆为框div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。您可以使用 display 属性改变生成的框的类型。这意味着，通过将 display 属性设置为 block，可以让行内元素（比如a元素）表现得像块级元素一样。还可以通过把 display 设置为 none，让生成的元素根本没有框。这样的话，该框及其所有内容就不再显示，不占用文档中的空间。但是在一种情况下，即使没有进行显式定义，也会创建块级元素。这种情况发生在把一些文本添加到一个块级元素（比如 div）的开头。即使没有把这些文本定义为段落，它也会被当作段落对待： CSS 定位机制CSS 有三种基本的定位机制：普通流、浮动和绝对定位。除非专门指定，否则所有框都在普通流中定位。也就是说，普通流中的元素的位置由元素在 (X)HTML 中的位置决定。块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。 CSS position 属性通过使用 position 属性，我们可以选择 4 种不同类型的定位，这会影响元素框生成的方式。position 属性值的含义：static元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。relative元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。absolute元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。fixed元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。提示：相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。 CSS 相对定位：相对定位是一个非常容易掌握的概念。如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 CSS 绝对定位：绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。对于定位的主要问题是要记住每种定位的意义。所以，现在让我们复习一下学过的知识吧：相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。 CSS 浮动：浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。在 CSS 中，我们通过 float 属性实现元素的浮动。","categories":[],"tags":[{"name":"HTML&&CSS基础","slug":"HTML-CSS基础","permalink":"http://yoursite.com/tags/HTML-CSS基础/"}]},{"title":"CSS之框模型","slug":"CSS之框模型","date":"2019-06-13T09:48:11.000Z","updated":"2019-06-13T09:57:00.960Z","comments":true,"path":"2019/06/13/CSS之框模型/","link":"","permalink":"http://yoursite.com/2019/06/13/CSS之框模型/","excerpt":"","text":"元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。内边距、边框和外边距都是可选的，默认值是零。但是，许多元素将由用户代理样式表设置外边距和内边距。可以通过将元素的 margin 和 padding 设置为零来覆盖这些浏览器样式。这可以分别进行，也可以使用通用选择器对所有元素进行设置： {margin: 0;padding: 0;}1、内边距元素的内边距在边框和内容区之间。控制该区域最简单的属性是 padding 属性。CSS padding 属性定义元素边框与元素内容之间的空白区域。也通过使用下面四个单独的属性，分别设置上、右、下、左内边距：•padding-top•padding-right•padding-bottom•padding-left2、边框在 HTML 中，我们使用表格来创建文本周围的边框，但是通过使用 CSS 边框属性，我们可以创建出效果出色的边框，并且可以应用于任何元素。元素外边距内就是元素的的边框 (border)。元素的边框就是围绕元素内容和内边据的一条或多条线。可以使用下面的单边边框样式属性：•border-top-style•border-right-style•border-bottom-style•border-left-style可以通过下列属性分别设置边框各边的宽度：•border-top-width•border-right-width•border-bottom-width•border-left-width可以通过下列属性分别设置边框各边的颜色：•border-top-color•border-right-color•border-bottom-color•border-left-color3、外边距设置外边距的最简单的方法就是使用 margin 属性。margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em。margin 可以设置为 auto。更常见的做法是为外边距设置长度值。可以使用下列任何一个属性来只设置相应上的外边距，而不会直接影响所有其他外边距：•margin-top•margin-right•margin-bottom•margin-left","categories":[],"tags":[{"name":"HTML&&CSS基础","slug":"HTML-CSS基础","permalink":"http://yoursite.com/tags/HTML-CSS基础/"}]},{"title":"CSS之选择器","slug":"CSS之选择器","date":"2019-05-30T04:49:13.000Z","updated":"2019-05-30T06:14:14.519Z","comments":true,"path":"2019/05/30/CSS之选择器/","link":"","permalink":"http://yoursite.com/2019/05/30/CSS之选择器/","excerpt":"","text":"1.类选择器（class）&lt;标签 class=”NAME”&gt; 类选择器允许以一种独立于文档元素的方式来制定样式语法： . + NAME {} 还可以结合元素选择器来使用 例如：标签.NAME {} ； 2.ID选择器&lt;标签 id=”NAME”&gt; 与类选择器大概类似，有细微的差别。语法： #NAME{}与类选择器的差别：1、只能在文档中使用一次 2、不能使用id词列表（不能结合使用） 3、可以独立声明ID选择器 例如：#NAME{}； 3.属性选择器&lt;标签 title=”NAME”&gt; 作用：可以根据元素中的属性或属性值来选取指定元素语法：元素[title=”NAME”] []里面为属性名 选取含有指定属性的元素,[属性名=”属性值”] 选取指定元素例如： [abc^=”def”] 选择 abc 属性值以 “def” 开头的所有元素 [abc$=”def”] 选择 abc 属性值以 “def” 结尾的所有元素 [abc*=”def”] 选择 abc 属性值中包含子串 “def” 的所有元素 4.后代选择器与子元素选择器后代选择器语法：父标签 子标签{} 对父元素任意后代起作用子元素选择器语法 ：父标签&gt;子标签{} 对父元素某个确定的子元素起作用 5.兄弟选择器语法： 元素 + 元素 {} 此选择器应用于需要选择紧接在另一个元素后的元素，而且二者有相同的父元素 元素 ~ 元素 {} 此选择器应用于需要选择的元素后面所有的兄弟元素注意：用一个结合符只能选择两个相邻兄弟中的第二个元素","categories":[],"tags":[{"name":"HTML&&CSS基础","slug":"HTML-CSS基础","permalink":"http://yoursite.com/tags/HTML-CSS基础/"}]},{"title":"近期总结","slug":"近期总结","date":"2019-05-29T10:16:39.000Z","updated":"2019-05-29T11:16:13.350Z","comments":true,"path":"2019/05/29/近期总结/","link":"","permalink":"http://yoursite.com/2019/05/29/近期总结/","excerpt":"","text":"1、近期学习内容：HTML&amp;CSS基础，Java基础，TC图形库，hexo+github博客美化 2、学习参考https://www.sxt.cn/Java_jQuery_in_action/History_Direction.html（Java资料） https://www.bilibili.com/video/av49126649（HTML&amp;CSS基础） https://codeabc.cn/bestans/post/concise-lesson-contents（TC图形库的简单使用） https://www.jianshu.com/p/1f8107a8778c（博客美化教程） 3、总结最近应组导师的要求，主要学习的还是HTML&amp;CSS,java已经搁置了一段时间没学了，等把html&amp;css学完了再继续，TC图形库的应用主要是因为我的工程实践项目的需要才去学习的，去看博客美化完全是因为自己的博客界面实在太丑了。想把它美化一下而已。对之后每一个小结的学习我都会发表自己的总结（之前实在是没太多的时间）。 4、LeetCode题目：1.删除链表中的结点：https://paste.ubuntu.com/p/34nn55nDCB/ 总结：链表问题要着重考虑内存的问题 5、下周进度：继续进阶学习HTML&amp;CSS。","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/周报/"}]},{"title":"搭建博客","slug":"搭建博客","date":"2019-05-27T08:11:10.000Z","updated":"2019-05-30T06:19:38.907Z","comments":true,"path":"2019/05/27/搭建博客/","link":"","permalink":"http://yoursite.com/2019/05/27/搭建博客/","excerpt":"","text":"今天给大家介绍一下如何新建自己的博客，方案是基于node.js上的hexo模块加github的空间和域名。请大家先搭建一下，好处就是不用花钱买空间，还可以绑定自己域名。 使用Hexo+Github一步步搭建属于自己的博客（安装好后按照这个一步步来就可以搭建好啦）：https://www.cnblogs.com/fengxiongZz/p/7707219.html Hexo框架下用NexT(v6.0+)主题美化博客（初级初级）：https://blog.csdn.net/weixin_39345384/article/details/80785373 hexo搭建个人博客–NexT主题优化（美化进阶）：https://www.jianshu.com/p/1f8107a8778c bilibili视频地址：https://www.bilibili.com/video/av23913382?from=search&amp;seid=18138002325834960823 node-js 的安装教程https://www.runoob.com/nodejs/nodejs-install-setup.html git 安装教程https://www.runoob.com/git/git-tutorial.html","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"Frist Project","slug":"Frist-Project","date":"2019-05-26T14:15:52.000Z","updated":"2019-05-30T04:40:48.504Z","comments":true,"path":"2019/05/26/Frist-Project/","link":"","permalink":"http://yoursite.com/2019/05/26/Frist-Project/","excerpt":"","text":"第一次的工程实践项目：TC图形库下的贪吃蛇小程序（需要安装easyX）从http://www.easyx.cn/ 下载后安装 我的源代码如下： #include&lt;stdio.h&gt; #include &lt;graphics.h&gt; #include &lt;conio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt;/*初始化操作*///宏定义上下左右键值 #define up 72 #define down 80 #define left 75 #define right 77 //每一个结点代表一节蛇身，采用双向链表方便定位结点typedef struct Snake{ int x; int y; struct Snake next,prior; }snake; //flag代表食物是否被吃 1表示吃了 0表示没吃struct Food{ int x; int y; int flag;}food; //先定义开始的四节蛇snake head,tail,p,q;snake s,_new; int direct=right; //初始化方向向左int length=4;int i;int score=-10; //初始化分数int speed=0; //游戏速度 /***/ void Chooselevel(); //选择难度void Initsnake(); //初始化蛇void Drawsnake(); //画蛇void Movesnake(); //移动蛇的坐标void Controlsnake(); //键盘控制蛇的移动void Creatfood(); //随机出现食物void Drawfood(); //画食物void Eatingfood(); //蛇吃到食物void Endgame(); //游戏结束 int main(){ Chooselevel(); Initsnake(); while(1) { while(!kbhit()) { if(food.flag==0) { Creatfood(); score+=10; } cleardevice(); loadimage(NULL, _T(&quot;背景.jpg&quot;)); Movesnake(); Drawsnake(); Drawfood(); Eatingfood(); Sleep(speed); } Controlsnake(); } return 0; } void Initsnake(){ //初始化一个640*480的窗口 initgraph(640,480); //给初始的四节蛇分配空间 head = (snake *)malloc(sizeof(snake)); tail = (snake *)malloc(sizeof(snake)); p = (snake*)malloc(sizeof(snake)); q = (snake*)malloc(sizeof(snake)); //初始化坐标 head-&gt;x=60; head-&gt;y=30; p-&gt;x = 50; p-&gt;y = 30; q-&gt;x = 40; q-&gt;y = 30; tail-&gt;x=30; tail-&gt;y=30; //创建链表 head-&gt;next = p; p-&gt;next = q; q-&gt;next = tail; tail-&gt;next = NULL; tail-&gt;prior=q; q-&gt;prior=p; p-&gt;prior=head; head-&gt;prior=NULL; } void Drawsnake(){ //设置蛇的颜色 setlinecolor(RED); setfillcolor(YELLOW); //遍历蛇身进行绘图 s=head; for(i=0;i&lt;length;i++) { fillrectangle(s-&gt;x,s-&gt;y,s-&gt;x+10,s-&gt;y+10); s=s-&gt;next; } } void Movesnake(){ //将蛇的坐标向下一步进行覆盖 s=head; while(1) { if(s-&gt;next==NULL) break; else s=s-&gt;next; } for(i=0;i&lt;length-1;i++) { s-&gt;x=s-&gt;prior-&gt;x; s-&gt;y=s-&gt;prior-&gt;y; s=s-&gt;prior; } //移动蛇头 switch(direct) { case up: head-&gt;y -= 10; break; case down: head-&gt;y += 10; break; case left: head-&gt;x -= 10; break; case right: head-&gt;x += 10; break; } } void Controlsnake(){ int move; move=getch(); //获取键盘输入判断移动方向 switch(move) { case up: if(direct!=down) direct=up; break; case down: if(direct!=up) direct=down; break; case left: if(direct!=right) direct=left; break; case right: if(direct!=left) direct=right; break; } } void Creatfood(){ //随机生成食物坐标 srand((unsigned int)time(NULL)); food.x=rand()%6410; food.y=rand()%4810; //遍历蛇身 排除食物出现在蛇身 s=head; for(i=0;i&lt;length;i++) { if(s-&gt;x==food.x&amp;&amp;s-&gt;y==food.y) { food.flag=0; } else { food.flag = 1; } s=s-&gt;next; } } void Drawfood(){ //设置食物颜色 setlinecolor(LIGHTRED); setfillcolor(LIGHTRED); fillroundrect(food.x,food.y,food.x+10,food.y+10,15,15);} void Eatingfood(){ //判断食物和蛇头是否重合 if(head-&gt;x==food.x&amp;&amp;head-&gt;y==food.y) { s=head; while (1) { if(s-&gt;next==NULL) break; s=s-&gt;next; } _new=(snake*)malloc(sizeof(snake)); _new-&gt;next=s-&gt;next; s-&gt;next=_new; _new-&gt;prior=s; length++; food.flag=0; } //蛇如果吃到自己则退出 s=tail; for(i=3;i&lt;length;i++) { if(head-&gt;x == s-&gt;x&amp;&amp;head-&gt;y == s-&gt;y) { while(1) { Endgame(); } } s=s-&gt;next; } //蛇如果撞到墙则退出游戏 if(head-&gt;x==-10||head-&gt;x==640||head-&gt;y==-10||head-&gt;y==480) { while(1) { Endgame(); } } } void Endgame(){ //设置文字格式 char temp[20]; itoa(score,temp,10); settextcolor(RED); settextstyle(50,25,”楷体”); //结束界面 cleardevice(); outtextxy(210,80,&quot;游戏结束&quot;); outtextxy(150,210,&quot;你的分数是：&quot;); outtextxy(450,210,temp); Sleep(10000); } void Chooselevel(){ char str[20]; printf(&quot;请输入难度（easy,normal,hard）：&quot;); scanf(&quot;%s&quot;,str); if(strcmp(str,&quot;easy&quot;)==0) { speed=300; } else if(strcmp(str,&quot;normal&quot;)==0) { speed=100; } else if(strcmp(str,&quot;hard&quot;)==0) { speed=50; } else { printf(&quot;输入错误！&quot;); exit(0); } }","categories":[],"tags":[{"name":"C语言项目","slug":"C语言项目","permalink":"http://yoursite.com/tags/C语言项目/"}]},{"title":"第三次","slug":"第三次","date":"2018-12-29T07:22:38.000Z","updated":"2019-05-27T08:32:56.144Z","comments":true,"path":"2018/12/29/第三次/","link":"","permalink":"http://yoursite.com/2018/12/29/第三次/","excerpt":"","text":"本周学习方向：指针和数组，指针数组和数组指针. 学习参考：C语言教材。https://www.bilibili.com/video/av27744141/?p=22 总结：数组名其实是数组第一个元素的地址，当指针指向数组元素的时候，我们可以对指针变量进行加减运算，这样做的意义相当于指向距离指针所在位置向前或向后第n个元素. 指针数组是一个数组，每个数组元素存放一个指针变量。数组指针是一个指针，它指向的是一个数组. LeetCode题目1代码： 1. https://paste.ubuntu.com/p/XGMvGGz4dp/2. https://paste.ubuntu.com/p/4JPjxsPh4M/ 3. https://paste.ubuntu.com/p/6QjKNDcbw3/ 思考：第二题感觉难度较大，借鉴了网上的代码，大概看懂了。 5.下周进度继续深入学习指针，指针和二维数组的关系.","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/周报/"}]},{"title":"第二次","slug":"第二次","date":"2018-12-14T05:46:36.000Z","updated":"2019-05-27T08:32:58.295Z","comments":true,"path":"2018/12/14/第二次/","link":"","permalink":"http://yoursite.com/2018/12/14/第二次/","excerpt":"","text":"本周学习方向：共用体的使用。 学习参考：C语言教材。http://www.runoob.com/cprogramming/c-unions.htmlhttps://blog.csdn.net/yuandm819/article/details/51087877 总结：共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。共用体占用的内存应足够存储共用体中最大的成员。 LeetCode题目1代码： 1. https://paste.ubuntu.com/p/BN9jvyzP8C/2. https://paste.ubuntu.com/p/YNQxmTzZns/ 3. https://paste.ubuntu.com/p/jqZgMBMntR/ 思考：这三个还蛮简单的，没啥思考的了。5.下周进度继续深入学习共用体和结构体。","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/周报/"}]},{"title":"第一次","slug":"第一次","date":"2018-11-21T14:04:32.000Z","updated":"2019-05-27T08:33:00.024Z","comments":true,"path":"2018/11/21/第一次/","link":"","permalink":"http://yoursite.com/2018/11/21/第一次/","excerpt":"","text":"本周学习方向：二维数组，字符数组，限制字符串长度的函数。 学习参考：C语言教材。https://blog.csdn.net/mcgrady_tracy/article/details/7529892https://blog.csdn.net/huaijiu123/article/details/79897843 总结：二维数组就类似于线性代数中的矩阵，只要把行列分清楚就可以简单掌握。字符数组的初始化要注意末尾是以\\0结束的，一般使用gets函数初始化，设定的数组长度还要多一位给‘\\0’占用. 访问数组中的元素可以采用数组名加下标的方式，下标是从0开始，c并不检查数组下标是否越界，所以在访问数组中的元素时需要注意，需要对数组下标做判断，防止访问数组越界。 LeetCode题目1代码： https://paste.ubuntu.com/p/jKQFbdZYKs/思考：用个for循环发重复项找出重复项，并使下一个不相同的数赋值给第一个与上一项不同的那个数组位置去，以此类推就可以删除。 下周进度学习共用体有关内容。","categories":[],"tags":[{"name":"周报","slug":"周报","permalink":"http://yoursite.com/tags/周报/"}]},{"title":"你好，hexo","slug":"你好，hexo","date":"2018-10-15T15:56:08.000Z","updated":"2018-10-15T15:56:08.419Z","comments":true,"path":"2018/10/15/你好，hexo/","link":"","permalink":"http://yoursite.com/2018/10/15/你好，hexo/","excerpt":"","text":"","categories":[],"tags":[]}]}